找出 n -1条权值最小的边很容易，那么怎么保证无回路呢？
如果在一个图中通过深度搜索或广度搜索判断有没有回路，则工作繁重。
有一种很好的办法——集合避圈法。

在生成树的过程中，我们把已经在生成树中的节点看作一个集合，把剩下的节点看作另一个集合，
从连接两个集合的边中选择一条权值最小的边即可。

---

直观地看图，很容易找出集合 U 到集合 V − U 的边中哪条边的权值是最小的，
但是在程序中如果穷举这些边，再找最小值，则时间复杂度太高，该怎么办呢？
可以通过设置两个数组巧妙地解决这个问题，
closest[ j ]表示集合 V − U 中的节点 j 到集合 U 中的最邻近点，
lowcost[ j ]表示集合 V − U 中的节点 j 到集合 U 中的最邻近点的边值，即边( j ,closest[ j ])的权值。
所以只需在集合 V − U 中找到lowcost[]值最小的节点即可。

---

```
（1）初始化。令集合 U ={ u 0 }， u 0 ∈ V ，并初始化数组closest[]、lowcost[]和 s []。

（2）在集合 V − U 中找lowcost值最小的节点 t ，即lowcost[ t ]=min{lowcost[ j ]| j ∈ V − U }，满足该公式的节点 t 就是集合 V − U 中连接集合 U 的最邻近点。

（3）将节点 t 加入集合 U 中。

（4）如果集合 V − U 为空，则算法结束，否则转向步骤5。

（5）对集合 V − U 中的所有节点 j 都更新其lowcost[]和closest[]。更新if( C [ t ][ j ]<lowcost [ j ]){ lowcost[ j ]= C [ t ] [ j ]; closest[ j ]= t ;}，转向步骤2。
```