通常的编码方法有固定长度编码和不等长编码两种。
这是一个设计最优编码方案的问题，目的是使总码长度最短。
这个问题是利用字符的使用频率来编码，是不等长编码方法，
使得经常使用的字符编码较短，不常使用的字符编码较长。

不等长编码方法需要解决两个关键问题：
①编码尽可能短，我们可以让使用频率高的字符编码较短，使用频率低的字符编码较长，
这种方法可以提高压缩率，节省空间，也能提高运算和通信速度，即频率越高，编码越短；
②不能有二义性。

哈夫曼编码的基本思想是以字符的使用频率作为权值构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。

构造一棵哈夫曼树，是将所要编码的字符作为叶子节点，将该字符在文件中的使用频率作为叶子节点的权值，
以自底向上的方式，通过 n -1次的“合并”运算后构造出的树。
其核心思想是让权值大的叶子离根最近。

哈夫曼算法采取的贪心策略是，每次都从树的集合中取出没有双亲且权值最小的两棵树作为左、右子树，
构造一棵新树，新树根节点的权值为其左、右孩子节点权值之和，将新树插入树的集合中。

```
（1）确定合适的数据结构。编写程序前需要考虑的情况如下。
 在哈夫曼树中，如果没有度为1的节点，则一棵有 n 个叶子节点的哈夫曼树共有2 n -1个节点（ n -1次的“合并”，每次都产生一个新节点）。
 构成哈夫曼树后，编码需要从叶子节点出发走一条从叶子到根的路径。译码需要从根出发走一条从根到叶子的路径。
 那么对于每个节点而言，需要知道每个节点的权值、双亲、左孩子、右孩子和节点的信息。
 
 （2）初始化。构造 n 棵节点为 n 个字符的单节点树集合 T ={ t 1 , t 2 , t 3 ,…, t n }，
 每棵树只有一个带权的根节点，权值为该字符的使用频率。
 
 （3）如果在 T 中只剩下一棵树，则哈夫曼树构造成功，跳到第6步。
  否则，从集合 T 中取出没有双亲且权值最小的两棵树 t i 和 t j ，将它们合并成一棵新树 z k ，
  新树的左孩子为 t i ，右孩子为 t j ， z k 的权值为 t i 和 t j 的权值之和。
 
 （4）从集合 T 中删去 t i 、 t j ，加入 z k 。

 （5）重复第（3）～（4）步。

 （6）约定左分支上的编码为“0”，右分支上的编码为“1”。
 从叶子节点到根节点逆向求出每个字符的哈夫曼编码。
 那么从根节点到叶子节点路径上的字符组成的字符串为该叶子节点的哈夫曼编码，算法结束。
```

---

### 处理冲突的方法

无论如何设计散列函数，都无法避免发生冲突。
如果发生冲突，就需要处理冲突。
处理冲突的方法分为3种：开放地址法、链地址法、建立公共溢出区。

1. 开放地址法

开放地址法是线性存储空间上的解决方案，也被称为闭散列。
当发生冲突时，采用冲突处理方法在线性存储空间上探测其他位置。
`hash′(key)=(hash(key)+ d i )% m `
其中，hash(key)为原散列函数，hash′(key)为探测函数， d i 为增量序列， m 为表长。
根据增量序列的不同，开放地址法又分为线性探测法、二次探测法、随机探测法、再散列法。

